{"version":3,"file":"signatureAuth.js","sourceRoot":"","sources":["../../../src/utils/signatureAuth.ts"],"names":[],"mappings":"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","sourcesContent":["import { web3 } from '@coral-xyz/anchor-31';\nimport bs58 from 'bs58';\nimport * as crypto from 'crypto';\nimport nacl from 'tweetnacl';\n\n/**\n * Configuration for signature-based authentication\n */\nexport interface SignatureAuthConfig {\n  /** Keypair for signing */\n  keypair: web3.Keypair;\n  /** Solana connection for fetching blockhash */\n  connection: web3.Connection;\n  /** Refresh interval in milliseconds (default: 5 minutes for signature freshness) */\n  refreshInterval?: number;\n}\n\n/**\n * Signed authentication data\n */\nexport interface SignedAuthData {\n  signature: string;\n  publicKey: string;\n  blockhash: string;\n  timestamp: number;\n}\n\n/**\n * Manages signature-based authentication for Switchboard service\n * Signs blockhash periodically to prove subscription and freshness\n */\nexport class SignatureAuth {\n  private keypair: web3.Keypair;\n  private connection: web3.Connection;\n  private refreshInterval: number;\n  private currentAuthData?: SignedAuthData;\n  private refreshTimer?: NodeJS.Timeout;\n  private lastRefreshTime: number = 0;\n\n  constructor(config: SignatureAuthConfig) {\n    this.keypair = config.keypair;\n    this.connection = config.connection;\n    this.refreshInterval = config.refreshInterval || 5 * 60 * 1000; // 5 minutes default (signature freshness window)\n  }\n\n  /**\n   * Check if signature auth is configured and enabled\n   */\n  public isEnabled(): boolean {\n    return !!(this.keypair && this.connection);\n  }\n\n  /**\n   * Get the current auth headers, refreshing if necessary\n   */\n  public async getAuthHeaders(): Promise<Record<string, string> | null> {\n    if (!this.isEnabled()) {\n      return null;\n    }\n\n    // Check if we need to refresh\n    const now = Date.now();\n    if (\n      !this.currentAuthData ||\n      now - this.lastRefreshTime >= this.refreshInterval\n    ) {\n      await this.refresh();\n    }\n\n    if (!this.currentAuthData) {\n      return null;\n    }\n\n    // Return auth headers\n    return {\n      'X-Switchboard-Signature': this.currentAuthData.signature,\n      'X-Switchboard-Pubkey': this.currentAuthData.publicKey,\n      'X-Switchboard-Blockhash': this.currentAuthData.blockhash,\n      'X-Switchboard-Timestamp': this.currentAuthData.timestamp.toString(),\n    };\n  }\n\n  /**\n   * Get the current auth data as an object (for WebSocket messages)\n   */\n  public async getAuthData(): Promise<SignedAuthData | null> {\n    if (!this.isEnabled()) {\n      return null;\n    }\n\n    // Check if we need to refresh\n    const now = Date.now();\n    if (\n      !this.currentAuthData ||\n      now - this.lastRefreshTime >= this.refreshInterval\n    ) {\n      await this.refresh();\n    }\n\n    return this.currentAuthData || null;\n  }\n\n  /**\n   * Refresh the signature by fetching latest blockhash and signing\n   */\n  public async refresh(): Promise<void> {\n    if (!this.isEnabled()) {\n      return;\n    }\n\n    try {\n      // Fetch latest blockhash\n      const { blockhash } = await this.connection.getLatestBlockhash();\n\n      // Create message to sign\n      const timestamp = Date.now();\n      const message = this.createMessage(blockhash, timestamp);\n\n      // Sign the message with Ed25519 using tweetnacl\n      const signatureBytes = nacl.sign.detached(\n        message,\n        this.keypair.secretKey\n      );\n\n      // Store the auth data (use base58 encoding - Solana standard)\n      this.currentAuthData = {\n        signature: bs58.encode(signatureBytes),\n        publicKey: this.keypair.publicKey.toBase58(),\n        blockhash,\n        timestamp,\n      };\n\n      this.lastRefreshTime = Date.now();\n    } catch (error) {\n      console.error('Failed to refresh signature auth:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Create the message to sign\n   * Format: SHA256(blockhash:timestamp)\n   */\n  private createMessage(blockhash: string, timestamp: number): Uint8Array {\n    // Message format: blockhash:timestamp\n    const messageStr = `${blockhash}:${timestamp}`;\n    const messageBuffer = Buffer.from(messageStr, 'utf-8');\n\n    // Hash the message with SHA256 (matches Rust implementation)\n    const hash = crypto.createHash('sha256').update(messageBuffer).digest();\n    return new Uint8Array(hash);\n  }\n\n  /**\n   * Start automatic refresh timer\n   */\n  public startAutoRefresh(): void {\n    if (!this.isEnabled()) {\n      return;\n    }\n\n    // Clear any existing timer\n    this.stopAutoRefresh();\n\n    // Refresh immediately\n    this.refresh().catch(err =>\n      console.error('Initial signature refresh failed:', err)\n    );\n\n    // Set up periodic refresh\n    this.refreshTimer = setInterval(() => {\n      this.refresh().catch(err =>\n        console.error('Signature refresh failed:', err)\n      );\n    }, this.refreshInterval);\n  }\n\n  /**\n   * Stop automatic refresh timer\n   */\n  public stopAutoRefresh(): void {\n    if (this.refreshTimer) {\n      clearInterval(this.refreshTimer);\n      this.refreshTimer = undefined;\n    }\n  }\n\n  /**\n   * Cleanup resources\n   */\n  public destroy(): void {\n    this.stopAutoRefresh();\n    this.currentAuthData = undefined;\n  }\n}\n"]}