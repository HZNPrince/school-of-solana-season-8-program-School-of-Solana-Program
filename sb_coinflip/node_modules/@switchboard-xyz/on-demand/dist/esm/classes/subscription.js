/**
 * Switchboard Subscription SDK
 *
 * High-level functions for managing Switchboard On-Demand subscriptions.
 * Allows users to create, upgrade, downgrade, and extend their subscriptions.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { asV0Tx } from '../index.js';
import { OracleQuote } from './oracleQuote.js';
import { BN, Program, web3 } from '@coral-xyz/anchor-31';
import { ASSOCIATED_TOKEN_PROGRAM_ID, getAssociatedTokenAddressSync, TOKEN_PROGRAM_ID, } from '@solana/spl-token';
import { PublicKey, SystemProgram, SYSVAR_CLOCK_PUBKEY, SYSVAR_INSTRUCTIONS_PUBKEY, SYSVAR_SLOT_HASHES_PUBKEY, } from '@solana/web3.js';
import { CrossbarClient } from '@switchboard-xyz/common';
/**
 * Switchboard Subscriber Program ID
 */
export const SUBSCRIPTION_PROGRAM_ID = new PublicKey('SbsCRB7Y3SGNEwVgvwE4R8ZYuhertgc7ekUXQbD6pNH');
/**
 * SWTCH Token Mint Address
 */
export const SWTCH_MINT = new PublicKey('SW1TCHLmRGTfW5xZknqQdpdarB8PD95sJYWpNp9TbFx');
/**
 * SWTCH/USDT Feed ID for oracle pricing
 */
export const SWTCH_FEED_ID = '148aaedb33ff23593805377f131af7fe01b4770ae2b9e4a2f7f8b3a180314711';
// ============================================================================
// PDA Derivation Helpers
// ============================================================================
/**
 * Derive the state PDA
 */
function getStatePda(programId) {
    return PublicKey.findProgramAddressSync([Buffer.from('STATE')], programId);
}
/**
 * Derive the tier PDA
 */
function getTierPda(tierId, programId) {
    return PublicKey.findProgramAddressSync([Buffer.from('TIER'), Buffer.from(new Uint16Array([tierId]).buffer)], programId);
}
/**
 * Derive the subscription PDA
 */
function getSubscriptionPda(owner, programId) {
    return PublicKey.findProgramAddressSync([Buffer.from('SUBSCRIPTION'), owner.toBuffer()], programId);
}
/**
 * Derive the token vault PDA
 */
function getTokenVaultPda(mint, programId) {
    return PublicKey.findProgramAddressSync([Buffer.from('TOKEN_VAULT'), mint.toBuffer()], programId);
}
// ============================================================================
// Oracle Helper
// ============================================================================
/**
 * Bundle oracle update with subscription instruction
 * (Pattern from test file's executeWithOracleUpdate function)
 */
function executeWithOracleUpdate(connection, queue, quoteAccount, subscriptionIx, signer) {
    return __awaiter(this, void 0, void 0, function* () {
        console.log(`Bundling oracle update for ${signer.publicKey.toBase58().slice(0, 8)}...`);
        // Create crossbar client (don't need to pass it in)
        const crossbar = new CrossbarClient('https://crossbar.switchboard.xyz');
        // Fetch oracle instructions with retry logic
        let oracleIxs;
        let retries = 0;
        const maxRetries = 5;
        while (retries < maxRetries) {
            try {
                const result = yield queue.fetchManagedUpdateIxs(crossbar, [SWTCH_FEED_ID], {
                    payer: signer.publicKey,
                    instructionIdx: 0,
                });
                oracleIxs = result;
                console.log(`Oracle instructions fetched: ${oracleIxs.length}`);
                break;
            }
            catch (e) {
                retries++;
                const errMsg = e instanceof Error ? e.message : String(e);
                console.log(`Oracle fetch failed (attempt ${retries}/${maxRetries}): ${errMsg.slice(0, 80)}`);
                if (retries >= maxRetries) {
                    throw new Error(`Oracle fetch failed after ${maxRetries} attempts. Last error: ${errMsg}`);
                }
                console.log('Retrying in 3 seconds...');
                yield new Promise(r => setTimeout(r, 3000));
            }
        }
        // Bundle in atomic transaction
        const tx = yield asV0Tx({
            connection,
            ixs: [...oracleIxs, subscriptionIx],
            signers: [signer],
            computeUnitPrice: 20000,
            computeUnitLimitMultiple: 1.3,
        });
        const sig = yield connection.sendTransaction(tx);
        yield connection.confirmTransaction(sig, 'confirmed');
        console.log(`Transaction confirmed: ${sig}`);
        // Rate limiting
        yield new Promise(r => setTimeout(r, 2000));
        return sig;
    });
}
/**
 * Get the canonical oracle quote account PDA
 */
function getQuoteAccount(queuePubkey) {
    // Use OracleQuote.getCanonicalPubkey directly - same as test file
    const [quoteAccount] = OracleQuote.getCanonicalPubkey(queuePubkey, [
        SWTCH_FEED_ID,
    ]);
    return quoteAccount;
}
/**
 * Load the Subscriber program (fetches IDL from on-chain)
 */
function loadSubscriberProgram(connection, programId) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const idl = yield Program.fetchIdl(programId, {
                connection,
            });
            if (!idl) {
                throw new Error('Subscriber program IDL not found on-chain');
            }
            return new Program(idl, {
                connection,
            });
        }
        catch (e) {
            throw new Error(`Failed to load Subscriber program IDL: ${e instanceof Error ? e.message : String(e)}`);
        }
    });
}
// ============================================================================
// Public API Functions
// ============================================================================
/**
 * Create a new subscription
 *
 * @example
 * ```typescript
 * const sig = await createSubscription({
 *   connection,
 *   payer: userKeypair,
 *   tierId: 2, // Pro tier
 *   epochAmount: 15,
 *   contactName: 'Alice',
 *   contactEmail: 'alice@example.com',
 *   queue,
 * });
 * ```
 */
export function createSubscription(params) {
    return __awaiter(this, void 0, void 0, function* () {
        const programId = SUBSCRIPTION_PROGRAM_ID;
        const program = yield loadSubscriberProgram(params.connection, programId);
        // Derive PDAs
        const [statePda] = getStatePda(programId);
        const [tierPda] = getTierPda(params.tierId, programId);
        const [subscriptionPda] = getSubscriptionPda(params.payer.publicKey, programId);
        const [tokenVaultPda] = getTokenVaultPda(SWTCH_MINT, programId);
        const payerTokenAccount = getAssociatedTokenAddressSync(SWTCH_MINT, params.payer.publicKey);
        const quoteAccount = getQuoteAccount(params.queue.pubkey);
        // Build subscription init instruction
        // Note: Program will auto-create SWTCH token account if needed (init_if_needed)
        const subscriptionIx = yield program.methods
            .subscriptionInit({
            tierId: params.tierId,
            contactName: params.contactName || null,
            contactEmail: params.contactEmail || null,
            epochAmount: new BN(params.epochAmount),
        })
            .accounts({
            state: statePda,
            subscription: subscriptionPda,
            tier: tierPda,
            owner: params.payer.publicKey,
            payer: params.payer.publicKey,
            paymentMint: SWTCH_MINT,
            payerTokenAccount,
            tokenVault: tokenVaultPda,
            tokenProgram: TOKEN_PROGRAM_ID,
            associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
            systemProgram: SystemProgram.programId,
            quoteAccount,
            sysvars: {
                clock: SYSVAR_CLOCK_PUBKEY,
                slothashes: SYSVAR_SLOT_HASHES_PUBKEY,
                instructions: SYSVAR_INSTRUCTIONS_PUBKEY,
            },
        })
            .instruction();
        // Execute with oracle update
        return executeWithOracleUpdate(params.connection, params.queue, quoteAccount, subscriptionIx, params.payer);
    });
}
/**
 * Upgrade subscription to a more expensive tier
 *
 * @example
 * ```typescript
 * const sig = await upgradeSubscription({
 *   connection,
 *   owner: userKeypair,
 *   newTierId: 3, // Surge tier
 *   epochAmount: 15,
 *   queue,
 * });
 * ```
 */
export function upgradeSubscription(params) {
    return __awaiter(this, void 0, void 0, function* () {
        const programId = SUBSCRIPTION_PROGRAM_ID;
        const program = yield loadSubscriberProgram(params.connection, programId);
        // Derive PDAs
        const [statePda] = getStatePda(programId);
        const [newTierPda] = getTierPda(params.newTierId, programId);
        const [subscriptionPda] = getSubscriptionPda(params.owner.publicKey, programId);
        const [tokenVaultPda] = getTokenVaultPda(SWTCH_MINT, programId);
        const ownerTokenAccount = getAssociatedTokenAddressSync(SWTCH_MINT, params.owner.publicKey);
        const quoteAccount = getQuoteAccount(params.queue.pubkey);
        // Fetch subscription to get current tier
        const subscription = yield program.account.subscription.fetch(subscriptionPda);
        const currentTierId = subscription.tierId;
        const [currentTierPda] = getTierPda(currentTierId, programId);
        // Build upgrade instruction
        const upgradeIx = yield program.methods
            .subscriptionUpgrade({
            newTierId: params.newTierId,
            epochAmount: new BN(params.epochAmount),
        })
            .accounts({
            state: statePda,
            subscription: subscriptionPda,
            newTier: newTierPda,
            owner: params.owner.publicKey,
            paymentMint: SWTCH_MINT,
            payerTokenAccount: ownerTokenAccount,
            tokenVault: tokenVaultPda,
            tokenProgram: TOKEN_PROGRAM_ID,
            quoteAccount,
            sysvars: {
                clock: SYSVAR_CLOCK_PUBKEY,
                slothashes: SYSVAR_SLOT_HASHES_PUBKEY,
                instructions: SYSVAR_INSTRUCTIONS_PUBKEY,
            },
        })
            .remainingAccounts([
            { pubkey: currentTierPda, isSigner: false, isWritable: false },
        ])
            .instruction();
        // Execute with oracle update
        return executeWithOracleUpdate(params.connection, params.queue, quoteAccount, upgradeIx, params.owner);
    });
}
/**
 * Downgrade subscription to a less expensive tier
 *
 * @example
 * ```typescript
 * const sig = await downgradeSubscription({
 *   connection,
 *   owner: userKeypair,
 *   newTierId: 1, // Free tier
 *   epochAmount: 15,
 *   queue,
 * });
 * ```
 */
export function downgradeSubscription(params) {
    return __awaiter(this, void 0, void 0, function* () {
        const programId = SUBSCRIPTION_PROGRAM_ID;
        const program = yield loadSubscriberProgram(params.connection, programId);
        // Derive PDAs
        const [statePda] = getStatePda(programId);
        const [newTierPda] = getTierPda(params.newTierId, programId);
        const [subscriptionPda] = getSubscriptionPda(params.owner.publicKey, programId);
        // Fetch subscription to get current tier
        const subscription = yield program.account.subscription.fetch(subscriptionPda);
        const currentTierId = subscription.tierId;
        const [currentTierPda] = getTierPda(currentTierId, programId);
        // Build downgrade instruction (credit-only, no payment)
        const downgradeIx = yield program.methods
            .subscriptionDowngrade({
            newTierId: params.newTierId,
            // No epochAmount - credit-only!
        })
            .accounts({
            state: statePda,
            subscription: subscriptionPda,
            newTier: newTierPda,
            owner: params.owner.publicKey,
        })
            .remainingAccounts([
            { pubkey: currentTierPda, isSigner: false, isWritable: false },
        ])
            .instruction();
        // Execute transaction (no oracle needed - credit-only operation)
        const tx = new web3.Transaction().add(downgradeIx);
        tx.recentBlockhash = (yield params.connection.getLatestBlockhash()).blockhash;
        tx.feePayer = params.owner.publicKey;
        tx.partialSign(params.owner);
        const sig = yield params.connection.sendRawTransaction(tx.serialize());
        const latestBlockhash = yield params.connection.getLatestBlockhash();
        yield params.connection.confirmTransaction({
            signature: sig,
            blockhash: latestBlockhash.blockhash,
            lastValidBlockHeight: latestBlockhash.lastValidBlockHeight,
        });
        return sig;
    });
}
/**
 * Extend an existing subscription
 *
 * @example
 * ```typescript
 * // User pays to extend
 * const sig = await extendSubscription({
 *   connection,
 *   owner: userKeypair,
 *   epochAmount: 10,
 *   queue,
 * });
 *
 * // Admin extends for free
 * const adminSig = await extendSubscription({
 *   connection,
 *   owner: adminKeypair,
 *   epochAmount: 30,
 *   adminExtend: true,
 * });
 * ```
 */
export function extendSubscription(params) {
    return __awaiter(this, void 0, void 0, function* () {
        const programId = SUBSCRIPTION_PROGRAM_ID;
        const program = yield loadSubscriberProgram(params.connection, programId);
        // Derive PDAs
        const [statePda] = getStatePda(programId);
        const [subscriptionPda] = getSubscriptionPda(params.owner.publicKey, programId);
        // Fetch subscription to get current tier
        const subscription = yield program.account.subscription.fetch(subscriptionPda);
        const currentTierId = subscription.tierId;
        const [tierPda] = getTierPda(currentTierId, programId);
        if (params.adminExtend) {
            // Admin extend - no payment or oracle needed
            const extendIx = yield program.methods
                .subscriptionExtend({
                epochAmount: new BN(params.epochAmount),
                adminExtend: true,
            })
                .accounts({
                state: statePda,
                subscription: subscriptionPda,
                tier: tierPda,
                payer: params.owner.publicKey,
                systemProgram: SystemProgram.programId,
            })
                .instruction();
            // Execute without oracle
            const tx = yield asV0Tx({
                connection: params.connection,
                ixs: [extendIx],
                signers: [params.owner],
                computeUnitPrice: 20000,
                computeUnitLimitMultiple: 1.3,
            });
            const sig = yield params.connection.sendTransaction(tx);
            yield params.connection.confirmTransaction(sig, 'confirmed');
            return sig;
        }
        else {
            // User extend - requires payment and oracle
            if (!params.queue) {
                throw new Error('queue required for paid extends');
            }
            const [tokenVaultPda] = getTokenVaultPda(SWTCH_MINT, programId);
            const payerTokenAccount = getAssociatedTokenAddressSync(SWTCH_MINT, params.owner.publicKey);
            const quoteAccount = getQuoteAccount(params.queue.pubkey);
            const extendIx = yield program.methods
                .subscriptionExtend({
                epochAmount: new BN(params.epochAmount),
                adminExtend: false,
            })
                .accounts({
                state: statePda,
                subscription: subscriptionPda,
                tier: tierPda,
                payer: params.owner.publicKey,
                paymentMint: SWTCH_MINT,
                payerTokenAccount,
                tokenVault: tokenVaultPda,
                tokenProgram: TOKEN_PROGRAM_ID,
                systemProgram: SystemProgram.programId,
                quoteAccount,
                sysvars: {
                    clock: SYSVAR_CLOCK_PUBKEY,
                    slothashes: SYSVAR_SLOT_HASHES_PUBKEY,
                    instructions: SYSVAR_INSTRUCTIONS_PUBKEY,
                },
            })
                .instruction();
            return executeWithOracleUpdate(params.connection, params.queue, quoteAccount, extendIx, params.owner);
        }
    });
}
/**
 * Add a team member to the subscription
 *
 * @example
 * ```typescript
 * const sig = await addTeamMember({
 *   connection,
 *   owner: userKeypair,
 *   user: teammatePublicKey,
 * });
 * ```
 */
export function addTeamMember(params) {
    return __awaiter(this, void 0, void 0, function* () {
        const programId = SUBSCRIPTION_PROGRAM_ID;
        const program = yield loadSubscriberProgram(params.connection, programId);
        // Derive PDAs
        const [statePda] = getStatePda(programId);
        const [subscriptionPda] = getSubscriptionPda(params.owner.publicKey, programId);
        // Fetch subscription to get current tier
        const subscription = yield program.account.subscription.fetch(subscriptionPda);
        const currentTierId = subscription.tierId;
        const [tierPda] = getTierPda(currentTierId, programId);
        const addIx = yield program.methods
            .subscriptionManageUsers({
            action: { add: {} },
            user: params.user,
        })
            .accounts({
            state: statePda,
            subscription: subscriptionPda,
            tier: tierPda,
            owner: params.owner.publicKey,
        })
            .instruction();
        // Execute without oracle (no payment)
        const tx = yield asV0Tx({
            connection: params.connection,
            ixs: [addIx],
            signers: [params.owner],
            computeUnitPrice: 20000,
            computeUnitLimitMultiple: 1.3,
        });
        const sig = yield params.connection.sendTransaction(tx);
        yield params.connection.confirmTransaction(sig, 'confirmed');
        return sig;
    });
}
/**
 * Remove a team member from the subscription
 *
 * @example
 * ```typescript
 * const sig = await removeTeamMember({
 *   connection,
 *   owner: userKeypair,
 *   user: teammatePublicKey,
 * });
 * ```
 */
export function removeTeamMember(params) {
    return __awaiter(this, void 0, void 0, function* () {
        const programId = SUBSCRIPTION_PROGRAM_ID;
        const program = yield loadSubscriberProgram(params.connection, programId);
        // Derive PDAs
        const [statePda] = getStatePda(programId);
        const [subscriptionPda] = getSubscriptionPda(params.owner.publicKey, programId);
        // Fetch subscription to get current tier
        const subscription = yield program.account.subscription.fetch(subscriptionPda);
        const currentTierId = subscription.tierId;
        const [tierPda] = getTierPda(currentTierId, programId);
        const removeIx = yield program.methods
            .subscriptionManageUsers({
            action: { remove: {} },
            user: params.user,
        })
            .accounts({
            state: statePda,
            subscription: subscriptionPda,
            tier: tierPda,
            owner: params.owner.publicKey,
        })
            .instruction();
        // Execute without oracle (no payment)
        const tx = yield asV0Tx({
            connection: params.connection,
            ixs: [removeIx],
            signers: [params.owner],
            computeUnitPrice: 20000,
            computeUnitLimitMultiple: 1.3,
        });
        const sig = yield params.connection.sendTransaction(tx);
        yield params.connection.confirmTransaction(sig, 'confirmed');
        return sig;
    });
}
/**
 * Fetch subscription information for an owner
 *
 * @example
 * ```typescript
 * const info = await fetchSubscriptionInfo({
 *   connection,
 *   owner: userPublicKey,
 * });
 *
 * console.log(`Tier: ${info.tierId}`);
 * console.log(`Active: ${info.isActive === 1}`);
 * console.log(`Epochs: ${info.subscriptionStartEpoch} - ${info.subscriptionEndEpoch}`);
 * ```
 */
export function fetchSubscriptionInfo(params) {
    return __awaiter(this, void 0, void 0, function* () {
        const programId = SUBSCRIPTION_PROGRAM_ID;
        const program = yield loadSubscriberProgram(params.connection, programId);
        const [subscriptionPda] = getSubscriptionPda(params.owner, programId);
        try {
            const subscription = yield program.account.subscription.fetch(subscriptionPda);
            return subscription;
        }
        catch (_a) {
            // Subscription doesn't exist
            return null;
        }
    });
}
/**
 * Close an existing subscription and reclaim rent
 *
 * Note: Subscription must be expired or inactive to close
 *
 * @example
 * ```typescript
 * const sig = await closeSubscription({
 *   connection,
 *   owner: userKeypair,
 *   destination: userKeypair.publicKey, // Where to send rent refund
 * });
 * ```
 */
export function closeSubscription(params) {
    return __awaiter(this, void 0, void 0, function* () {
        const programId = SUBSCRIPTION_PROGRAM_ID;
        const program = yield loadSubscriberProgram(params.connection, programId);
        // Derive subscription PDA
        const [subscriptionPda] = getSubscriptionPda(params.owner.publicKey, programId);
        const destination = params.destination || params.owner.publicKey;
        // Build close instruction
        const closeIx = yield program.methods
            .subscriptionClose({})
            .accounts({
            subscription: subscriptionPda,
            owner: params.owner.publicKey,
            destination,
        })
            .instruction();
        // Execute transaction
        const tx = new web3.Transaction().add(closeIx);
        const latestBlockhash = yield params.connection.getLatestBlockhash();
        tx.recentBlockhash = latestBlockhash.blockhash;
        tx.feePayer = params.owner.publicKey;
        tx.partialSign(params.owner);
        const sig = yield params.connection.sendRawTransaction(tx.serialize());
        yield params.connection.confirmTransaction({
            signature: sig,
            blockhash: latestBlockhash.blockhash,
            lastValidBlockHeight: latestBlockhash.lastValidBlockHeight,
        });
        return sig;
    });
}
// ============================================================================
// INSTRUCTION-ONLY FUNCTIONS (for wallet adapters)
// ============================================================================
/**
 * Build create subscription instruction (does not send transaction)
 * Use this for wallet adapters that need to sign transactions
 *
 * @example
 * ```typescript
 * const ix = await createSubscriptionIx({
 *   connection,
 *   owner: userPublicKey,
 *   tierId: 2,
 *   epochAmount: 15,
 *   queue,
 * });
 * // Sign and send with wallet adapter
 * await sendTransaction(transaction.add(ix), connection);
 * ```
 */
export function createSubscriptionIx(params) {
    return __awaiter(this, void 0, void 0, function* () {
        const programId = SUBSCRIPTION_PROGRAM_ID;
        const program = yield loadSubscriberProgram(params.connection, programId);
        // Derive PDAs
        const [statePda] = getStatePda(programId);
        const [tierPda] = getTierPda(params.tierId, programId);
        const [subscriptionPda] = getSubscriptionPda(params.owner, programId);
        const [tokenVaultPda] = getTokenVaultPda(SWTCH_MINT, programId);
        const payerTokenAccount = getAssociatedTokenAddressSync(SWTCH_MINT, params.owner);
        const quoteAccount = getQuoteAccount(params.queue.pubkey);
        // Build subscription init instruction
        const subscriptionIx = yield program.methods
            .subscriptionInit({
            tierId: params.tierId,
            contactName: params.contactName || null,
            contactEmail: params.contactEmail || null,
            epochAmount: new BN(params.epochAmount),
        })
            .accounts({
            state: statePda,
            subscription: subscriptionPda,
            tier: tierPda,
            owner: params.owner,
            payer: params.owner,
            paymentMint: SWTCH_MINT,
            payerTokenAccount,
            tokenVault: tokenVaultPda,
            tokenProgram: TOKEN_PROGRAM_ID,
            associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
            systemProgram: SystemProgram.programId,
            quoteAccount,
            sysvars: {
                clock: SYSVAR_CLOCK_PUBKEY,
                slothashes: SYSVAR_SLOT_HASHES_PUBKEY,
                instructions: SYSVAR_INSTRUCTIONS_PUBKEY,
            },
        })
            .instruction();
        return subscriptionIx;
    });
}
/**
 * Build upgrade subscription instruction (does not send transaction)
 *
 * @example
 * ```typescript
 * const ix = await upgradeSubscriptionIx({
 *   connection,
 *   owner: userPublicKey,
 *   newTierId: 3,
 *   epochAmount: 15,
 *   queue,
 * });
 * ```
 */
export function upgradeSubscriptionIx(params) {
    return __awaiter(this, void 0, void 0, function* () {
        const programId = SUBSCRIPTION_PROGRAM_ID;
        const program = yield loadSubscriberProgram(params.connection, programId);
        // Derive PDAs
        const [statePda] = getStatePda(programId);
        const [newTierPda] = getTierPda(params.newTierId, programId);
        const [subscriptionPda] = getSubscriptionPda(params.owner, programId);
        const [tokenVaultPda] = getTokenVaultPda(SWTCH_MINT, programId);
        const ownerTokenAccount = getAssociatedTokenAddressSync(SWTCH_MINT, params.owner);
        const quoteAccount = getQuoteAccount(params.queue.pubkey);
        // Fetch subscription to get current tier
        const subscription = yield program.account.subscription.fetch(subscriptionPda);
        const currentTierId = subscription.tierId;
        const [currentTierPda] = getTierPda(currentTierId, programId);
        // Build upgrade instruction
        const upgradeIx = yield program.methods
            .subscriptionUpgrade({
            newTierId: params.newTierId,
            epochAmount: new BN(params.epochAmount),
        })
            .accounts({
            state: statePda,
            subscription: subscriptionPda,
            newTier: newTierPda,
            owner: params.owner,
            paymentMint: SWTCH_MINT,
            payerTokenAccount: ownerTokenAccount,
            tokenVault: tokenVaultPda,
            tokenProgram: TOKEN_PROGRAM_ID,
            quoteAccount,
            sysvars: {
                clock: SYSVAR_CLOCK_PUBKEY,
                slothashes: SYSVAR_SLOT_HASHES_PUBKEY,
                instructions: SYSVAR_INSTRUCTIONS_PUBKEY,
            },
        })
            .remainingAccounts([
            { pubkey: currentTierPda, isSigner: false, isWritable: false },
        ])
            .instruction();
        return upgradeIx;
    });
}
/**
 * Build downgrade subscription instruction (does not send transaction)
 * Note: Downgrade is credit-only, no oracle needed
 *
 * @example
 * ```typescript
 * const ix = await downgradeSubscriptionIx({
 *   connection,
 *   owner: userPublicKey,
 *   newTierId: 1,
 * });
 * ```
 */
export function downgradeSubscriptionIx(params) {
    return __awaiter(this, void 0, void 0, function* () {
        const programId = SUBSCRIPTION_PROGRAM_ID;
        const program = yield loadSubscriberProgram(params.connection, programId);
        // Derive PDAs
        const [statePda] = getStatePda(programId);
        const [newTierPda] = getTierPda(params.newTierId, programId);
        const [subscriptionPda] = getSubscriptionPda(params.owner, programId);
        // Fetch subscription to get current tier
        const subscription = yield program.account.subscription.fetch(subscriptionPda);
        const currentTierId = subscription.tierId;
        const [currentTierPda] = getTierPda(currentTierId, programId);
        // Build downgrade instruction (credit-only, no payment)
        const downgradeIx = yield program.methods
            .subscriptionDowngrade({
            newTierId: params.newTierId,
        })
            .accounts({
            state: statePda,
            subscription: subscriptionPda,
            newTier: newTierPda,
            owner: params.owner,
        })
            .remainingAccounts([
            { pubkey: currentTierPda, isSigner: false, isWritable: false },
        ])
            .instruction();
        return downgradeIx;
    });
}
/**
 * Build extend subscription instruction (does not send transaction)
 *
 * @example
 * ```typescript
 * const ix = await extendSubscriptionIx({
 *   connection,
 *   owner: userPublicKey,
 *   epochAmount: 10,
 *   queue,
 * });
 * ```
 */
export function extendSubscriptionIx(params) {
    return __awaiter(this, void 0, void 0, function* () {
        const programId = SUBSCRIPTION_PROGRAM_ID;
        const program = yield loadSubscriberProgram(params.connection, programId);
        // Derive PDAs
        const [statePda] = getStatePda(programId);
        const [subscriptionPda] = getSubscriptionPda(params.owner, programId);
        // Fetch subscription to get current tier
        const subscription = yield program.account.subscription.fetch(subscriptionPda);
        const currentTierId = subscription.tierId;
        const [tierPda] = getTierPda(currentTierId, programId);
        if (params.adminExtend) {
            // Admin extend - no payment or oracle needed
            const extendIx = yield program.methods
                .subscriptionExtend({
                epochAmount: new BN(params.epochAmount),
                adminExtend: true,
            })
                .accounts({
                state: statePda,
                subscription: subscriptionPda,
                tier: tierPda,
                payer: params.owner,
                systemProgram: SystemProgram.programId,
            })
                .instruction();
            return extendIx;
        }
        else {
            // User extend - requires payment and oracle
            if (!params.queue) {
                throw new Error('queue required for paid extends');
            }
            const [tokenVaultPda] = getTokenVaultPda(SWTCH_MINT, programId);
            const payerTokenAccount = getAssociatedTokenAddressSync(SWTCH_MINT, params.owner);
            const quoteAccount = getQuoteAccount(params.queue.pubkey);
            const extendIx = yield program.methods
                .subscriptionExtend({
                epochAmount: new BN(params.epochAmount),
                adminExtend: false,
            })
                .accounts({
                state: statePda,
                subscription: subscriptionPda,
                tier: tierPda,
                payer: params.owner,
                paymentMint: SWTCH_MINT,
                payerTokenAccount,
                tokenVault: tokenVaultPda,
                tokenProgram: TOKEN_PROGRAM_ID,
                systemProgram: SystemProgram.programId,
                quoteAccount,
                sysvars: {
                    clock: SYSVAR_CLOCK_PUBKEY,
                    slothashes: SYSVAR_SLOT_HASHES_PUBKEY,
                    instructions: SYSVAR_INSTRUCTIONS_PUBKEY,
                },
            })
                .instruction();
            return extendIx;
        }
    });
}
/**
 * Build add team member instruction (does not send transaction)
 *
 * @example
 * ```typescript
 * const ix = await addTeamMemberIx({
 *   connection,
 *   owner: userPublicKey,
 *   user: teamMemberPublicKey,
 * });
 * ```
 */
export function addTeamMemberIx(params) {
    return __awaiter(this, void 0, void 0, function* () {
        const programId = SUBSCRIPTION_PROGRAM_ID;
        const program = yield loadSubscriberProgram(params.connection, programId);
        // Derive PDAs
        const [statePda] = getStatePda(programId);
        const [subscriptionPda] = getSubscriptionPda(params.owner, programId);
        // Fetch subscription to get current tier
        const subscription = yield program.account.subscription.fetch(subscriptionPda);
        const currentTierId = subscription.tierId;
        const [tierPda] = getTierPda(currentTierId, programId);
        const addIx = yield program.methods
            .subscriptionManageUsers({
            action: { add: {} },
            user: params.user,
        })
            .accounts({
            state: statePda,
            subscription: subscriptionPda,
            tier: tierPda,
            owner: params.owner,
        })
            .instruction();
        return addIx;
    });
}
/**
 * Build remove team member instruction (does not send transaction)
 *
 * @example
 * ```typescript
 * const ix = await removeTeamMemberIx({
 *   connection,
 *   owner: userPublicKey,
 *   user: teamMemberPublicKey,
 * });
 * ```
 */
export function removeTeamMemberIx(params) {
    return __awaiter(this, void 0, void 0, function* () {
        const programId = SUBSCRIPTION_PROGRAM_ID;
        const program = yield loadSubscriberProgram(params.connection, programId);
        // Derive PDAs
        const [statePda] = getStatePda(programId);
        const [subscriptionPda] = getSubscriptionPda(params.owner, programId);
        // Fetch subscription to get current tier
        const subscription = yield program.account.subscription.fetch(subscriptionPda);
        const currentTierId = subscription.tierId;
        const [tierPda] = getTierPda(currentTierId, programId);
        const removeIx = yield program.methods
            .subscriptionManageUsers({
            action: { remove: {} },
            user: params.user,
        })
            .accounts({
            state: statePda,
            subscription: subscriptionPda,
            tier: tierPda,
            owner: params.owner,
        })
            .instruction();
        return removeIx;
    });
}
/**
 * Build close subscription instruction (does not send transaction)
 *
 * @example
 * ```typescript
 * const ix = await closeSubscriptionIx({
 *   connection,
 *   owner: userPublicKey,
 *   destination: userPublicKey,
 * });
 * ```
 */
export function closeSubscriptionIx(params) {
    return __awaiter(this, void 0, void 0, function* () {
        const programId = SUBSCRIPTION_PROGRAM_ID;
        const program = yield loadSubscriberProgram(params.connection, programId);
        // Derive subscription PDA
        const [subscriptionPda] = getSubscriptionPda(params.owner, programId);
        const destination = params.destination || params.owner;
        // Build close instruction
        const closeIx = yield program.methods
            .subscriptionClose({})
            .accounts({
            subscription: subscriptionPda,
            owner: params.owner,
            destination,
        })
            .instruction();
        return closeIx;
    });
}
// ============================================================================
// ADMIN SDK - Program Authority Functions
// ============================================================================
/**
 * Initialize the subscriber program state (one-time setup, admin only)
 *
 * Must be called by program upgrade authority
 *
 * @example
 * ```typescript
 * const sig = await initializeState({
 *   connection,
 *   authority: authorityKeypair,
 *   swtchMint: new PublicKey('SW1TCH...'),
 *   swtchFeedId: '148aaedb33ff23593805377f131af7fe01b4770ae2b9e4a2f7f8b3a180314711',
 * });
 * ```
 */
export function initializeState(params) {
    return __awaiter(this, void 0, void 0, function* () {
        const programId = SUBSCRIPTION_PROGRAM_ID;
        const program = yield loadSubscriberProgram(params.connection, programId);
        const payer = params.payer || params.authority;
        // Derive state PDA
        const [statePda] = getStatePda(programId);
        // Derive program data PDA (for upgrade authority check)
        const BPF_LOADER_UPGRADEABLE = new PublicKey('BPFLoaderUpgradeab1e11111111111111111111111');
        const [programDataPda] = PublicKey.findProgramAddressSync([programId.toBuffer()], BPF_LOADER_UPGRADEABLE);
        // Convert hex string to byte array
        const hexStr = params.swtchFeedId.replace(/^0x/, '');
        const swtchFeedId = Array.from(Buffer.from(hexStr, 'hex'));
        if (swtchFeedId.length !== 32) {
            throw new Error('Feed ID must be 32 bytes (64 hex characters)');
        }
        const stateParams = {
            swtchMint: params.swtchMint,
            swtchFeedId,
        };
        const ix = yield program.methods
            .stateInit(stateParams)
            .accounts({
            state: statePda,
            payer: payer.publicKey,
            authority: params.authority.publicKey,
            programData: programDataPda,
        })
            .instruction();
        // Execute transaction
        const tx = new web3.Transaction().add(ix);
        const latestBlockhash = yield params.connection.getLatestBlockhash();
        tx.recentBlockhash = latestBlockhash.blockhash;
        tx.feePayer = payer.publicKey;
        const signers = [payer];
        if (params.authority.publicKey.toBase58() !== payer.publicKey.toBase58()) {
            signers.push(params.authority);
        }
        tx.partialSign(...signers);
        const sig = yield params.connection.sendRawTransaction(tx.serialize());
        yield params.connection.confirmTransaction({
            signature: sig,
            blockhash: latestBlockhash.blockhash,
            lastValidBlockHeight: latestBlockhash.lastValidBlockHeight,
        });
        return sig;
    });
}
/**
 * Update program state configuration (admin only)
 *
 * @example
 * ```typescript
 * const sig = await updateStateConfig({
 *   connection,
 *   authority: authorityKeypair,
 *   swtchMint: new PublicKey('NEW_MINT...'),
 *   swtchFeedId: 'new_feed_id_hex',
 * });
 * ```
 */
export function updateStateConfig(params) {
    return __awaiter(this, void 0, void 0, function* () {
        const programId = SUBSCRIPTION_PROGRAM_ID;
        const program = yield loadSubscriberProgram(params.connection, programId);
        const [statePda] = getStatePda(programId);
        let swtchFeedIdBytes = null;
        if (params.swtchFeedId) {
            const hexStr = params.swtchFeedId.replace(/^0x/, '');
            const bytes = Array.from(Buffer.from(hexStr, 'hex'));
            if (bytes.length !== 32) {
                throw new Error('Feed ID must be 32 bytes (64 hex characters)');
            }
            swtchFeedIdBytes = bytes;
        }
        const updateParams = {
            swtchMint: params.swtchMint || null,
            swtchFeedId: swtchFeedIdBytes,
            epochLength: params.epochLength ? new BN(params.epochLength) : null,
        };
        const ix = yield program.methods
            .stateUpdateConfig(updateParams)
            .accounts({
            state: statePda,
            authority: params.authority.publicKey,
        })
            .instruction();
        const tx = new web3.Transaction().add(ix);
        const latestBlockhash = yield params.connection.getLatestBlockhash();
        tx.recentBlockhash = latestBlockhash.blockhash;
        tx.feePayer = params.authority.publicKey;
        tx.partialSign(params.authority);
        const sig = yield params.connection.sendRawTransaction(tx.serialize());
        yield params.connection.confirmTransaction({
            signature: sig,
            blockhash: latestBlockhash.blockhash,
            lastValidBlockHeight: latestBlockhash.lastValidBlockHeight,
        });
        return sig;
    });
}
/**
 * Create a new pricing tier (admin only)
 *
 * @example
 * ```typescript
 * const sig = await createTier({
 *   connection,
 *   authority: authorityKeypair,
 *   tierId: 2,
 *   name: 'Pro',
 *   displayName: 'Pro Plan',
 *   description: 'Professional tier with enhanced limits',
 *   maxConnections: 15,
 *   maxFeeds: 300,
 *   maxFeedsPerIx: 6,
 *   minDelayMs: 300,
 *   maxAuthorizedUsers: 5,
 *   costPerEpochUsdCents: 10000, // 100 USD per epoch
 *   isPublic: true,
 * });
 * ```
 */
export function createTier(params) {
    return __awaiter(this, void 0, void 0, function* () {
        const programId = SUBSCRIPTION_PROGRAM_ID;
        const program = yield loadSubscriberProgram(params.connection, programId);
        const payer = params.payer || params.authority;
        const [statePda] = getStatePda(programId);
        const [tierPda] = getTierPda(params.tierId, programId);
        const tierParams = {
            tierId: params.tierId,
            name: params.name,
            displayName: params.displayName,
            description: params.description,
            maxConnections: params.maxConnections,
            maxFeeds: params.maxFeeds,
            maxFeedsPerIx: params.maxFeedsPerIx,
            minDelayMs: params.minDelayMs,
            maxAuthorizedUsers: params.maxAuthorizedUsers,
            costPerEpochUsdCents: new BN(params.costPerEpochUsdCents),
            isPublic: params.isPublic,
        };
        const ix = yield program.methods
            .tierCreate(tierParams)
            .accounts({
            state: statePda,
            tier: tierPda,
            payer: payer.publicKey,
            authority: params.authority.publicKey,
        })
            .instruction();
        const tx = new web3.Transaction().add(ix);
        const latestBlockhash = yield params.connection.getLatestBlockhash();
        tx.recentBlockhash = latestBlockhash.blockhash;
        tx.feePayer = payer.publicKey;
        const signers = [payer];
        if (params.authority.publicKey.toBase58() !== payer.publicKey.toBase58()) {
            signers.push(params.authority);
        }
        tx.partialSign(...signers);
        const sig = yield params.connection.sendRawTransaction(tx.serialize());
        yield params.connection.confirmTransaction({
            signature: sig,
            blockhash: latestBlockhash.blockhash,
            lastValidBlockHeight: latestBlockhash.lastValidBlockHeight,
        });
        return sig;
    });
}
/**
 * Update an existing tier (admin only)
 *
 * All parameters are optional - only provided values will be updated
 *
 * @example
 * ```typescript
 * const sig = await updateTier({
 *   connection,
 *   authority: authorityKeypair,
 *   tierId: 2,
 *   costPerEpochUsdCents: 15000, // Update price to 150 USD
 *   minDelayMs: 100, // Update rate limit
 * });
 * ```
 */
export function updateTier(params) {
    return __awaiter(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g;
        const programId = SUBSCRIPTION_PROGRAM_ID;
        const program = yield loadSubscriberProgram(params.connection, programId);
        const [statePda] = getStatePda(programId);
        const [tierPda] = getTierPda(params.tierId, programId);
        const updateParams = {
            name: params.name || null,
            displayName: params.displayName || null,
            description: params.description || null,
            maxConnections: (_a = params.maxConnections) !== null && _a !== void 0 ? _a : null,
            maxFeeds: (_b = params.maxFeeds) !== null && _b !== void 0 ? _b : null,
            maxFeedsPerIx: (_c = params.maxFeedsPerIx) !== null && _c !== void 0 ? _c : null,
            minDelayMs: (_d = params.minDelayMs) !== null && _d !== void 0 ? _d : null,
            maxAuthorizedUsers: (_e = params.maxAuthorizedUsers) !== null && _e !== void 0 ? _e : null,
            costPerEpochUsdCents: params.costPerEpochUsdCents
                ? new BN(params.costPerEpochUsdCents)
                : null,
            isPublic: (_f = params.isPublic) !== null && _f !== void 0 ? _f : null,
            enabled: (_g = params.enabled) !== null && _g !== void 0 ? _g : null,
        };
        const ix = yield program.methods
            .tierUpdate(updateParams)
            .accounts({
            state: statePda,
            tier: tierPda,
            authority: params.authority.publicKey,
        })
            .instruction();
        const tx = new web3.Transaction().add(ix);
        const latestBlockhash = yield params.connection.getLatestBlockhash();
        tx.recentBlockhash = latestBlockhash.blockhash;
        tx.feePayer = params.authority.publicKey;
        tx.partialSign(params.authority);
        const sig = yield params.connection.sendRawTransaction(tx.serialize());
        yield params.connection.confirmTransaction({
            signature: sig,
            blockhash: latestBlockhash.blockhash,
            lastValidBlockHeight: latestBlockhash.lastValidBlockHeight,
        });
        return sig;
    });
}
/**
 * Admin-managed subscription update (admin only)
 *
 * Allows admins to forcefully change tier, activate/deactivate, extend for free, or update contact info
 *
 * @example
 * ```typescript
 * // Force tier change
 * const sig = await adminManageSubscription({
 *   connection,
 *   authority: authorityKeypair,
 *   owner: new PublicKey('user...'),
 *   setTierId: 3,
 * });
 *
 * // Extend subscription for free
 * const sig = await adminManageSubscription({
 *   connection,
 *   authority: authorityKeypair,
 *   owner: new PublicKey('user...'),
 *   extendEpochs: 30,
 * });
 *
 * // Deactivate subscription
 * const sig = await adminManageSubscription({
 *   connection,
 *   authority: authorityKeypair,
 *   owner: new PublicKey('user...'),
 *   setActive: false,
 * });
 * ```
 */
export function adminManageSubscription(params) {
    return __awaiter(this, void 0, void 0, function* () {
        var _a, _b;
        const programId = SUBSCRIPTION_PROGRAM_ID;
        const program = yield loadSubscriberProgram(params.connection, programId);
        const [statePda] = getStatePda(programId);
        const [subscriptionPda] = getSubscriptionPda(params.owner, programId);
        const adminParams = {
            setTierId: (_a = params.setTierId) !== null && _a !== void 0 ? _a : null,
            setActive: (_b = params.setActive) !== null && _b !== void 0 ? _b : null,
            extendEpochs: params.extendEpochs ? new BN(params.extendEpochs) : null,
            updateContactName: params.updateContactName || null,
            updateContactEmail: params.updateContactEmail || null,
        };
        const ix = yield program.methods
            .subscriptionAdminManage(adminParams)
            .accounts({
            state: statePda,
            subscription: subscriptionPda,
            authority: params.authority.publicKey,
        })
            .instruction();
        const tx = new web3.Transaction().add(ix);
        const latestBlockhash = yield params.connection.getLatestBlockhash();
        tx.recentBlockhash = latestBlockhash.blockhash;
        tx.feePayer = params.authority.publicKey;
        tx.partialSign(params.authority);
        const sig = yield params.connection.sendRawTransaction(tx.serialize());
        yield params.connection.confirmTransaction({
            signature: sig,
            blockhash: latestBlockhash.blockhash,
            lastValidBlockHeight: latestBlockhash.lastValidBlockHeight,
        });
        return sig;
    });
}
/**
 * Admin-only tier change with automatic pro-rating (admin only)
 *
 * @example
 * ```typescript
 * const sig = await adminSetTier({
 *   connection,
 *   authority: authorityKeypair,
 *   owner: new PublicKey('user...'),
 *   newTierId: 3,
 * });
 * ```
 */
export function adminSetTier(params) {
    return __awaiter(this, void 0, void 0, function* () {
        const programId = SUBSCRIPTION_PROGRAM_ID;
        const program = yield loadSubscriberProgram(params.connection, programId);
        const [statePda] = getStatePda(programId);
        const [subscriptionPda] = getSubscriptionPda(params.owner, programId);
        // Fetch subscription to get current tier
        const subscription = yield program.account.subscription.fetch(subscriptionPda);
        const currentTierId = subscription.tierId;
        const [newTierPda] = getTierPda(params.newTierId, programId);
        const [oldTierPda] = getTierPda(currentTierId, programId);
        const tierParams = {
            newTierId: params.newTierId,
        };
        const ix = yield program.methods
            .subscriptionSetTier(tierParams)
            .accounts({
            state: statePda,
            subscription: subscriptionPda,
            newTier: newTierPda,
            oldTier: oldTierPda,
            authority: params.authority.publicKey,
        })
            .instruction();
        const tx = new web3.Transaction().add(ix);
        const latestBlockhash = yield params.connection.getLatestBlockhash();
        tx.recentBlockhash = latestBlockhash.blockhash;
        tx.feePayer = params.authority.publicKey;
        tx.partialSign(params.authority);
        const sig = yield params.connection.sendRawTransaction(tx.serialize());
        yield params.connection.confirmTransaction({
            signature: sig,
            blockhash: latestBlockhash.blockhash,
            lastValidBlockHeight: latestBlockhash.lastValidBlockHeight,
        });
        return sig;
    });
}
//# sourceMappingURL=subscription.js.map